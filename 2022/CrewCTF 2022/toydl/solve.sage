from Crypto.Util.number import long_to_bytes

# pow(2, x, n) = 3, x->4152237283178332171134427748246949134982804474039336295768576937291496455801204299012426384686186488437732239040578895582345754862866682517210666664694634622481210828533924801356654788767923906990970085179367631860096183689780636009399349964086944154244464319415042044821978154315541151745635117768984279951229194
# pow(2, x, n) = 9, x->3754939778354158910107789877335886849355087278630804477809002556307824523516424124875830766489409359374346298779402434539775766276216233569237231723341252968455894584408143678496101610613389877101646294181565422615598678053423609327485531311004778211836628609338110226534895570202818439605250908707603466887326390

n = 9099069576005010864322131238316022841221043338895736227456302636550336776171968946298044005765927235002236358603510713249831486899034262930368203212096032559091664507617383780759417104649503558521835589329751163691461155254201486010636703570864285313772976190442467858988008292898546327400223671343777884080302269
e = 65537
c = 7721448675656271306770207905447278771344900690929609366254539633666634639656550740458154588923683190330091584419635454991419701119568903552077272516472473602367188377791329158090763546083264422552335660922148840678536264063681459356778292303287448582918945582522946194737497041408425657842265913159282583371732459
x1 = 4152237283178332171134427748246949134982804474039336295768576937291496455801204299012426384686186488437732239040578895582345754862866682517210666664694634622481210828533924801356654788767923906990970085179367631860096183689780636009399349964086944154244464319415042044821978154315541151745635117768984279951229194
x2 = 3754939778354158910107789877335886849355087278630804477809002556307824523516424124875830766489409359374346298779402434539775766276216233569237231723341252968455894584408143678496101610613389877101646294181565422615598678053423609327485531311004778211836628609338110226534895570202818439605250908707603466887326390
assert pow(2, x1, n) == 3
assert pow(2, x2, n) == 9
X = 2 * x1 - x2
# X % (p - 1) == 0 and X % (q - 1) == 0
X_factors = [x for (x, m) in factor(X) for _ in range(m)]
assert reduce(lambda x, y: x * y, X_factors) == X

# Pollard's p-1 algorithm
# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm

def factor(n):
  a = 2
  b = 2
  while True:
    a = power_mod(a, b, n)
    p = gcd(a - 1, n)
    if 1 < p < n:
      return p
    b += 1

# q = factor(n)
q = 2667409485887452272770831798706991010944832728754072378737171107257239406526140122282372492002898629230454157958918945658178559315566157078990098518311104787
p = n // q
assert is_prime(p) and is_prime(q) and p * q == n
assert X % (p - 1) == 0 and X % (q - 1) == 0

d = inverse_mod(e, (p - 1) * (q - 1))
m = pow(c, d, n)
flag = long_to_bytes(int(m)).decode().strip('@')
assert flag == 'crew{d15cr373_l06_15_r3duc710n_f0r_f4c70r1n6}'
print(flag)
